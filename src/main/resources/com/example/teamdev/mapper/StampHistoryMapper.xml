<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.teamdev.mapper.StampHistoryMapper">
    <!--対象年月、対象従業員IDの打刻記録情報を取得する-->
    <!--対象年月の日数分行を取得したいので、MySQLのSQL文でカレンダーテーブル（generated_dates）を作成し、右外部結合する-->
    <select id="getStampHistoryByYearMonthEmployeeId" parameterType="map"
            resultType="com.example.teamdev.entity.StampHistoryDisplay">
        SELECT
            sh.id AS id,
            to_char(gd.date, 'YYYY') AS year,
            to_char(gd.date, 'MM') AS month,
            to_char(gd.date, 'DD') AS day,
            CASE EXTRACT(DOW FROM gd.date)
                WHEN 0 THEN '日'
                WHEN 1 THEN '月'
                WHEN 2 THEN '火'
                WHEN 3 THEN '水'
                WHEN 4 THEN '木'
                WHEN 5 THEN '金'
                WHEN 6 THEN '土'
            END AS "dayOfWeek",
            #{employeeId} AS "employeeId",
            concat_ws(' ', COALESCE(emp.first_name, ''), COALESCE(emp.last_name, '')) AS "employeeName",
            concat_ws(' ', COALESCE(emp2.first_name, ''), COALESCE(emp2.last_name, '')) AS "updateEmployeeName",
            to_char(sh.in_time AT TIME ZONE 'Asia/Tokyo', 'HH24:MI') AS "inTime",
            to_char(sh.out_time AT TIME ZONE 'Asia/Tokyo', 'HH24:MI') AS "outTime",
            to_char(sh.break_start_time AT TIME ZONE 'Asia/Tokyo', 'HH24:MI') AS "breakStartTime",
            to_char(sh.break_end_time AT TIME ZONE 'Asia/Tokyo', 'HH24:MI') AS "breakEndTime",
            CASE WHEN sh.id IS NOT NULL THEN 0 ELSE NULL END AS "overtimeMinutes",
            sh.in_time AS "inTimeRaw",
            sh.out_time AS "outTimeRaw",
            sh.break_start_time AS "breakStartTimeRaw",
            sh.break_end_time AS "breakEndTimeRaw",
            sh.is_night_shift AS "isNightShift",
            to_char(sh.update_date AT TIME ZONE 'Asia/Tokyo', 'YYYY/MM/DD HH24:MI') AS "updateDate"
        FROM (
            <foreach collection="datesInMonth" item="date" separator=" UNION ALL ">
                SELECT CAST(#{date} AS DATE) AS date
            </foreach>
        ) AS gd
        LEFT JOIN stamp_history sh ON
            to_char(gd.date, 'YYYY') = sh.year AND
            to_char(gd.date, 'MM') = sh.month AND
            to_char(gd.date, 'DD') = sh.day AND
            sh.employee_id = #{employeeId}
        LEFT JOIN employee emp ON emp.id = #{employeeId}
        LEFT JOIN employee emp2 ON sh.update_employee_id = emp2.id
        ORDER BY gd.date ASC
    </select>

    <!-- データを挿入または更新する -->
    <!--①saveStampHistory→saveに修正②ON DUPLICATE KEY UPDATEの重複のキー削除-->
    <!--③IFNULL関数追記-->
    <insert id="save" parameterType="com.example.teamdev.entity.StampHistory">
        INSERT INTO stamp_history (
            id, year, month, day, employee_id, in_time, out_time, break_start_time, break_end_time,
            is_night_shift, update_employee_id, update_date
        ) VALUES (
            DEFAULT, #{year}, #{month}, #{day}, #{employeeId}, #{inTime}, #{outTime}, #{breakStartTime}, #{breakEndTime},
            #{isNightShift}, #{updateEmployeeId}, #{updateDate}
        )
    </insert>
    <!--更新の追記-->
    <!--動的SQL: in_time/out_time が null の場合は既存値を保持、break_start_time/break_end_time/is_night_shift は常に更新（削除可能）-->
    <update id="update" parameterType="com.example.teamdev.entity.StampHistory">
        UPDATE stamp_history
        SET
            year = #{year},
            month = #{month},
            day = #{day},
            <if test="inTime != null">
                in_time = #{inTime},
            </if>
            <if test="outTime != null">
                out_time = #{outTime},
            </if>
            break_start_time = #{breakStartTime},
            break_end_time = #{breakEndTime},
            is_night_shift = #{isNightShift},
            update_employee_id = #{updateEmployeeId},
            update_date = #{updateDate}
        WHERE id = #{id}
    </update>

    <select id="selectDailyAttendance" resultType="com.example.teamdev.service.dto.DailyAttendanceRecord">
        SELECT
            sh.in_time AS attendanceTime,
            sh.break_start_time AS breakStartTime,
            sh.break_end_time AS breakEndTime,
            sh.out_time AS departureTime
        FROM stamp_history sh
        WHERE sh.employee_id = #{employeeId}
          AND TO_DATE(sh.year || sh.month || sh.day, 'YYYYMMDD') = #{date}
        LIMIT 1
    </select>

    <!--月次勤怠統計を取得する-->
    <select id="findMonthlyStatistics" resultType="com.example.teamdev.entity.MonthlyAttendanceStats">
        SELECT
            to_char(DATE_TRUNC('month', CONCAT(sh.year, '-', sh.month, '-01')::date), 'YYYY-MM') AS month,
            COALESCE(
                ROUND(
                    SUM(
                        CASE
                            WHEN sh.out_time IS NOT NULL THEN
                                EXTRACT(EPOCH FROM (sh.out_time - sh.in_time)) / 3600.0
                                - CASE
                                    WHEN sh.break_start_time IS NOT NULL AND sh.break_end_time IS NOT NULL
                                        AND sh.break_end_time > sh.break_start_time THEN
                                        EXTRACT(EPOCH FROM (sh.break_end_time - sh.break_start_time)) / 3600.0
                                    ELSE
                                        COALESCE((e.profile_metadata->>'schedule')::jsonb->>'breakMinutes', '0')::numeric / 60.0
                                END
                            ELSE 0
                        END
                    )::numeric, 2
                ), 0
            ) AS totalHours,
            COALESCE(
                ROUND(
                    SUM(
                        GREATEST(
                            CASE
                                WHEN sh.out_time IS NOT NULL THEN
                                    EXTRACT(EPOCH FROM (sh.out_time - sh.in_time)) / 3600.0
                                    - CASE
                                        WHEN sh.break_start_time IS NOT NULL AND sh.break_end_time IS NOT NULL
                                            AND sh.break_end_time > sh.break_start_time THEN
                                            EXTRACT(EPOCH FROM (sh.break_end_time - sh.break_start_time)) / 3600.0
                                        ELSE
                                            COALESCE((e.profile_metadata->>'schedule')::jsonb->>'breakMinutes', '0')::numeric / 60.0
                                    END
                                    - 8.0
                                ELSE 0
                            END, 0
                        )
                    )::numeric, 2
                ), 0
            ) AS overtimeHours,
            COALESCE(
                SUM(
                    CASE
                        WHEN sh.in_time IS NOT NULL
                            AND (e.profile_metadata->>'schedule')::jsonb->>'start' IS NOT NULL
                            AND CAST(to_char(sh.in_time AT TIME ZONE 'Asia/Tokyo', 'HH24:MI') AS TIME)
                                > CAST((e.profile_metadata->>'schedule')::jsonb->>'start' AS TIME)
                        THEN 1
                        ELSE 0
                    END
                )::integer, 0
            ) AS lateCount
        FROM stamp_history sh
        INNER JOIN employee e ON sh.employee_id = e.id
        WHERE sh.employee_id = #{employeeId}
            AND to_char(CONCAT(sh.year, '-', sh.month, '-01')::date, 'YYYY-MM') >= #{startMonth}
            AND to_char(CONCAT(sh.year, '-', sh.month, '-01')::date, 'YYYY-MM') <![CDATA[<=]]> #{endMonth}
        GROUP BY to_char(DATE_TRUNC('month', CONCAT(sh.year, '-', sh.month, '-01')::date), 'YYYY-MM')
        ORDER BY month ASC
    </select>
</mapper>
