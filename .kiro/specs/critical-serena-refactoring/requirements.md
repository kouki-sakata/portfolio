# Requirements Document

## はじめに

本仕様書は、Serena MCPツールを活用したクリティカルなリファクタリングに関する要件を定義します。Serena MCPの強力なシンボリック解析機能を用いて、プロジェクトの最も重要な技術的課題のみに焦点を当て、コードベースの品質、保守性、パフォーマンスを向上させることを目的としています。

### ビジネス価値
- **技術的負債の削減**: 最も影響度の高い技術的負債のみを解消
- **保守性の向上**: 複雑度の高いコードを単純化し、将来の開発速度を向上
- **品質の向上**: 型安全性とテストカバレッジの強化により、バグを未然に防止
- **パフォーマンス改善**: クリティカルパスの最適化により、システム全体のレスポンス向上

### スコープ
本リファクタリングは以下の領域に限定されます：
- 認知的複雑度が15を超える高複雑度メソッド
- 型安全性違反（any/unknown型の使用）
- テストカバレッジが80%未満のクリティカルビジネスロジック
- パフォーマンスボトルネックとなっているデータベースクエリとAPI
- 重複コードパターンの削減

## Requirements

### Requirement 1: Serena MCPによるコード品質分析

**User Story:** 開発者として、Serena MCPツールを使用してコードベースの品質問題を自動的に特定したい。そうすることで、最も影響度の高い問題に効率的に対処できるようになる。

#### Acceptance Criteria

1. WHEN Serena MCPの`find_symbol`ツールを使用してJavaサービスクラスを解析するとき THEN システムはすべてのメソッドの認知的複雑度を特定しなければならない

2. WHEN 認知的複雑度が15を超えるメソッドが検出されたとき THEN システムはそのメソッド名、ファイルパス、複雑度スコアをリスト化しなければならない

3. WHEN Serena MCPの`search_for_pattern`ツールを使用してTypeScriptファイルを解析するとき THEN システムは`any`型または`unknown`型の使用箇所をすべて特定しなければならない

4. WHERE クリティカルビジネスロジック（認証、打刻計算、給与計算）が存在する THE システムはテストカバレッジが80%未満のコードを特定しなければならない

5. WHEN Serena MCPの`find_referencing_symbols`ツールを使用するとき THEN システムは循環依存や不適切な結合度を持つモジュールを検出しなければならない

6. IF 重複コードパターンが3箇所以上で検出された場合 THEN システムはそのパターンをDRY原則違反として報告しなければならない

### Requirement 2: 高複雑度メソッドのリファクタリング

**User Story:** 開発者として、認知的複雑度の高いメソッドを単純化したい。そうすることで、コードの理解と保守が容易になり、バグのリスクが低減される。

#### Acceptance Criteria

1. WHEN 認知的複雑度が15を超えるメソッドをリファクタリングするとき THEN リファクタリング後の複雑度は10以下に削減されなければならない

2. IF メソッドが複数の責任を持つ場合 THEN 単一責任の原則に従って複数の小さなメソッドに分割しなければならない

3. WHEN リファクタリングを実行した後 THEN 既存のすべてのテストが引き続き成功しなければならない

4. WHERE 複雑なビジネスロジックが存在する THE リファクタリング後のコードには適切なコメントとドキュメントが追加されなければならない

5. WHEN 条件分岐が5つ以上のメソッドをリファクタリングするとき THEN ストラテジーパターンまたはポリモーフィズムを使用して分岐を削減しなければならない

### Requirement 3: 型安全性の強化

**User Story:** 開発者として、TypeScriptコードベースからany/unknown型を排除したい。そうすることで、コンパイル時の型チェックによりランタイムエラーを防止できる。

#### Acceptance Criteria

1. WHEN TypeScriptファイル内で`any`型が使用されているとき THEN 適切な具体的型定義またはジェネリック型に置き換えなければならない

2. IF `unknown`型が必要な場合 THEN 型ガード関数を実装して安全に型を絞り込まなければならない

3. WHEN API レスポンス型を定義するとき THEN OpenAPI仕様から自動生成された型を使用しなければならない

4. WHERE フォームバリデーションが存在する THE Zodスキーマを使用してランタイムとコンパイルタイムの両方で型安全性を保証しなければならない

5. WHEN 外部ライブラリの型定義が不完全な場合 THEN カスタム型定義ファイル（.d.ts）を作成して型安全性を補完しなければならない

6. IF 型キャストが必要な場合 THEN `as`キャストではなく型述語（Type Predicate）関数を使用しなければならない

### Requirement 4: テストカバレッジの改善

**User Story:** 開発者として、クリティカルビジネスロジックのテストカバレッジを向上させたい。そうすることで、リファクタリングや機能追加時の回帰バグを防止できる。

#### Acceptance Criteria

1. WHEN Serena MCPツールでテストカバレッジ不足を特定したとき THEN 認証サービスのカバレッジは90%以上に向上しなければならない

2. WHERE 打刻計算ロジックが存在する THE すべてのエッジケース（深夜勤務、日跨ぎ、休憩時間）に対するテストが追加されなければならない

3. WHEN 新しいテストケースを追加するとき THEN AAA（Arrange-Act-Assert）パターンに従って実装しなければならない

4. IF APIエンドポイントがクリティカルな場合 THEN 統合テスト（MSW使用）とE2Eテスト（Playwright使用）の両方を実装しなければならない

5. WHEN データベース操作を含むサービスをテストするとき THEN Testcontainersを使用して実際のデータベース環境でテストしなければならない

6. WHERE エラーハンドリングロジックが存在する THE すべてのエラーケース（ネットワークエラー、バリデーションエラー、認証エラー）に対するテストが実装されなければならない

### Requirement 5: パフォーマンス最適化

**User Story:** 開発者として、システムのパフォーマンスボトルネックを特定して最適化したい。そうすることで、ユーザー体験が向上し、システムの応答性が改善される。

#### Acceptance Criteria

1. WHEN Serena MCPツールでデータベースクエリを分析するとき THEN N+1クエリ問題が存在するコードを特定しなければならない

2. IF N+1クエリ問題が検出された場合 THEN バッチロードまたはJOIN句を使用してクエリを最適化しなければならない

3. WHEN APIエンドポイントのレスポンス時間を測定するとき THEN p95パーセンタイルが200ms以下でなければならない

4. WHERE 大量データを返すAPIが存在する THE ページネーションまたはカーソルベースのページングを実装しなければならない

5. WHEN フロントエンドバンドルサイズを分析するとき THEN クリティカルルートのJavaScriptバンドルは300KB以下でなければならない

6. IF 遅いデータベースクエリが検出された場合 THEN 適切なインデックスを追加してクエリ実行時間を50%以上削減しなければならない

7. WHEN React Queryのキャッシュ設定を最適化するとき THEN クリティカルデータのstaleTimeとgcTimeは適切に設定されなければならない

### Requirement 6: コード重複の削減

**User Story:** 開発者として、コードベース全体の重複コードを特定して統合したい。そうすることで、DRY原則に従い、保守性が向上する。

#### Acceptance Criteria

1. WHEN Serena MCPの`search_for_pattern`ツールで重複パターンを検索するとき THEN 10行以上の類似コードブロックをすべて検出しなければならない

2. IF 同一または類似のロジックが3箇所以上で使用されている場合 THEN 共通関数またはユーティリティクラスに抽出しなければならない

3. WHERE 複数のAPIクライアントで同様のエラーハンドリングが存在する THE 共通のエラーハンドリングミドルウェアまたはインターセプターに統合しなければならない

4. WHEN バリデーションロジックが重複している場合 THEN Zodスキーマまたはカスタムバリデーター関数として共通化しなければならない

5. IF コンポーネント間で類似のUIロジックが存在する場合 THEN カスタムフックまたは共有コンポーネントに抽出しなければならない

### Requirement 7: ドキュメントと保守性の向上

**User Story:** 開発者として、リファクタリングされたコードに適切なドキュメントを追加したい。そうすることで、将来の開発者がコードを理解しやすくなる。

#### Acceptance Criteria

1. WHEN 複雑なビジネスロジックをリファクタリングした後 THEN JSDocまたはJavaDocコメントでロジックの意図を文書化しなければならない

2. WHERE 公開APIメソッドが存在する THE すべてのパラメータ、戻り値、例外について文書化しなければならない

3. IF アルゴリズムや計算ロジックが非自明な場合 THEN インラインコメントで計算の根拠や前提条件を説明しなければならない

4. WHEN 新しいユーティリティ関数を作成するとき THEN 使用例を含むドキュメントを追加しなければならない

5. WHERE 型定義が複雑な場合 THE TypeScriptのコメントで型の意図と使用方法を説明しなければならない

## 非機能要件

### パフォーマンス要件
- リファクタリング後のAPI応答時間は現状比で10%以上改善されること
- フロントエンドバンドルサイズは現状比で15%以上削減されること
- データベースクエリの実行時間は現状比で30%以上改善されること

### 品質要件
- リファクタリング後のコードカバレッジは85%以上であること
- すべての既存テストが成功すること
- 新規追加されたテストは100%成功すること
- Biomeの静的解析で警告が0件であること

### 保守性要件
- 認知的複雑度が15を超えるメソッドが0件であること
- any/unknown型の使用が0件であること（型ガード使用を除く）
- 重複コードブロック（10行以上）が3箇所未満であること
